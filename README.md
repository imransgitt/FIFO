# RTL to GDS Synthesis of Asynchronous 16 Deep 8 Bit FIFO

This project demonstrates the complete synthesis flow of an asynchronous FIFO (First-In-First-Out) memory with a depth of 16 and a data width of 8 bits using open-source synthesis tools. The synthesis flow covers Verilog description, RTL verification, synthesis, placement, routing, layout, and static timing analysis.

## Tools Used

- **Icarus Verilog**: Verilog description and RTL verification
- **GTKWave**: Waveform viewer for RTL verification
- **Yosys**: RTL synthesis
- **blifFandout**: High fanout net synthesis
- **Graywolf**: Placement
- **Q-router**: Detailed Routing
- **Magic**: VLSI Layout tool
- **Netgen**: LVS (Layout vs. Schematic)
- **OpenSTA**: Static timing analysis Tool

## Project Structure

The project consists of the following files and directories:

- `rtl/`: Contains Verilog description of the FIFO module (`fifo.v`) and any other RTL files.
- `tests/`: Contains testbenches and test vectors for RTL verification.
- `scripts/`: Contains synthesis scripts for Yosys, placement and routing scripts for Graywolf and Q-router, and any other automation scripts.
- `synthesis/`: Output directory for synthesized netlist and intermediate files.
- `layout/`: Output directory for layout files generated by Magic.
- `reports/`: Contains synthesis reports, timing analysis reports, and any other documentation.

## Synthesis Flow

1. **RTL Description and Verification**: 
   - Write Verilog description of the FIFO module (`fifo.v`) in the `rtl/` directory.
   - Write testbenches and test vectors for RTL verification in the `tests/` directory.
   - Verify the functionality of the RTL design using Icarus Verilog and GTKWave.

2. **RTL Synthesis**:
   - Use Yosys to synthesize the RTL design (`fifo.v`) to a gate-level netlist.
   - Save synthesized netlist and reports in the `synthesis/` directory.

3. **High Fanout Net Synthesis**:
   - Utilize blifFandout to optimize high fanout nets in the synthesized netlist.

4. **Placement**:
   - Employ Graywolf for placement of the synthesized netlist.

5. **Routing**:
   - Use Q-router for detailed routing of the placed netlist.

6. **Layout**:
   - Utilize Magic to generate the layout of the routed netlist.

7. **Layout vs. Schematic (LVS)**:
   - Verify the layout against the schematic using Netgen.

8. **Static Timing Analysis**:
   - Perform static timing analysis using OpenSTA to ensure timing constraints are met.

## Usage

1. Clone this repository.
2. Place Verilog description (`fifo.v`) and testbenches in the appropriate directories (`rtl/` and `tests/` respectively).
3. Run synthesis scripts in the `scripts/` directory for each step of the synthesis flow.
4. Review reports and generated files in the respective directories (`synthesis/`, `layout/`, `reports/`) for analysis and debugging.

## Author

Imran S

## License

Completely opensourced



# Verilog FIFO Module

This Verilog module implements a FIFO (First-In-First-Out) memory with a depth of 16 and a data width of 8 bits. It provides functionality for write and read operations, as well as status indicators for full and empty conditions.

## Module Inputs

- `clk`: Clock signal
- `reset`: Reset signal
- `d_in`: Input data
- `wr_en`: Write enable signal
- `rd_en`: Read enable signal

## Module Outputs

- `full`: Indicates if the FIFO is full
- `empty`: Indicates if the FIFO is empty
- `d_out`: Output data
- `fifo_counter`: Current occupancy of the FIFO (number of elements stored)

## Parameters

- `DATA_WIDTH`: Width of the data bus (default: 8)
- `DEPTH`: Depth of the FIFO (default: 16)

## Implementation Details

- The FIFO is implemented using a circular buffer approach.
- Memory is implemented as a register array.
- Read and write pointers are used to manage data access.
- Full and empty conditions are determined based on the `fifo_counter`.

## Behavior

- When the FIFO is not empty (`!empty`) and a read operation is enabled (`rd_en`), the oldest data is read from the FIFO.
- When the FIFO is not full (`!full`) and a write operation is enabled (`wr_en`), new data is written to the FIFO.
- If the FIFO is empty, reading will return a default value (`0` in this implementation).
- If the FIFO is full, writing will not modify the FIFO content.

## How to Use

1. Instantiate the module in your Verilog design.
2. Connect the inputs (`clk`, `reset`, `d_in`, `wr_en`, `rd_en`) and outputs (`full`, `empty`, `d_out`, `fifo_counter`) as required.
3. Ensure proper clocking of the `clk` signal.
4. Assert `reset` signal to initialize the FIFO.
5. Use `wr_en` to write data into the FIFO and `rd_en` to read data from the FIFO.
6. Check `full` and `empty` signals to determine the status of the FIFO.
7. Utilize `d_out` for reading the data from the FIFO.

## Example

```verilog
module top_module (
    // your module ports
);

fifo my_fifo (
    .clk(clk),
    .reset(reset),
    .d_in(data_input),
    .wr_en(write_enable),
    .rd_en(read_enable),
    .full(fifo_full),
    .empty(fifo_empty),
    .d_out(data_output),
    .fifo_counter(fifo_count)
);

// instantiate your design components and connect to the FIFO

endmodule
